#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t CarveMaze(int32_t a1, int64_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t GenerateMaze(int32_t a1, int64_t a2, int32_t a3);
void make_immortal(void);
int32_t ShowMaze(int32_t a1, int64_t a2, uint32_t a3);
int32_t sig_alarm_handler(int32_t a1);

// --------------------- Global Variables ---------------------

struct _IO_FILE * g1 = (struct _IO_FILE *)0x80ec2a0; // 0x80ec558

// ------------------------ Functions -------------------------

// Address range: 0x8048880 - 0x80488b0
int32_t sig_alarm_handler(int32_t a1) {
    // 0x8048880
    puts("Sorry, too slow.");
    fflush((struct _IO_FILE *)*(int32_t *)0x80ec558);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x80488c0 - 0x8048979
int32_t ShowMaze(int32_t a1, int64_t a2, uint32_t a3) {
    // 0x80488c0
    if (a3 <= 0) {
        // 0x8048960
        return fflush(g1);
    }
    int32_t v1 = a2;
    int32_t v2 = 0;
    // branch -> 0x804893b
    while (true) {
        // 0x804893b
        if (v1 > 0) {
            int32_t v3 = (int32_t)((int64_t)v2 * a2) + a1; // 0x80488e7
            int32_t v4 = 0;
            // branch -> 0x80488db
            while (true) {
                // 0x80488db
                switch (*(char *)(v3 + v4)) {
                    default: {
                        // 0x8048926
                        printf("  ");
                        // branch -> 0x8048937
                        break;
                    }
                    case 1: {
                        // 0x8048902
                        printf("[]");
                        // branch -> 0x8048937
                        break;
                    }
                    case 2: {
                        // 0x8048914
                        printf("<>");
                        // branch -> 0x8048937
                        break;
                    }
                }
                int32_t v5 = v4 + 1; // 0x8048937
                if (v5 >= v1) {
                    // break (via goto) -> 0x8048943
                    goto lab_0x8048943;
                }
                v4 = v5;
                // continue -> 0x80488db
            }
        } else {
          lab_0x8048943:
            // 0x8048943
            putchar(10);
            int32_t v6 = v2 + 1; // 0x8048950
            if (v6 >= a3) {
                // break -> 0x8048960
                break;
            }
            v2 = v6;
            // continue -> 0x804893b
            continue;
        }
    }
    // 0x8048960
    return fflush(g1);
}

// Address range: 0x8048980 - 0x8048b0f
int32_t CarveMaze(int32_t a1, int64_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = rand();
    // branch -> 0x8048afd
    while (true) {
        int32_t v2 = 0; // 0x8048afd3947
        int32_t v3 = v1 % 4; // 0x8048af24046
        // branch -> 0x80489ad
        int32_t result; // 0x8048af2
        while (true) {
            int32_t v4 = 0; // 0x8048a0842
            int32_t v5 = 1; // 0x8048a1341
            int32_t v6; // 0x80489f5
            int32_t v7; // 0x8048a00
            int32_t v8; // 0x8048a0b
            int32_t v9; // 0x8048a16
            if (v3 != 1) {
                // 0x80489c3
                if (v3 != 2) {
                    // 0x80489c8
                    v4 = v3 == 0;
                    v5 = v3 != 0;
                    // branch -> 0x80489ef
                } else {
                    v4 = -1;
                    v5 = 0;
                }
                // 0x80489ef
                v6 = v4 + a4;
                v7 = v5 + a5;
                v8 = v6 + v4;
                v9 = v7 + v5;
                if (v8 >= 1) {
                  lab_0x8048a25:
                    // 0x8048a25
                    if (v9 < a3 && v8 < (int32_t)a2 && v9 > 0) {
                        char * v10 = (char *)(v6 + a1 + (int32_t)((int64_t)v7 * a2));
                        if (*v10 == 1) {
                            char * v11 = (char *)(v8 + a1 + (int32_t)((int64_t)v9 * a2));
                            if (*v11 == 1) {
                                // 0x8048a7f
                                *v10 = 0;
                                *v11 = 0;
                                rand();
                                rand();
                                // branch -> 0x8048afd
                                break;
                            }
                        }
                    }
                }
              lab_0x8048adf:
                // 0x8048adf
                result = (v3 + 1) % 4;
                int32_t v12 = v2 + 1; // 0x8048af9
                if (v12 >= 4) {
                    // break -> 0x8048b07
                    break;
                }
                v2 = v12;
                v3 = result;
                // continue -> 0x80489ad
                continue;
            }
            // 0x80489ef
            v6 = v4 + a4;
            v7 = v5 + a5;
            v8 = v6 + v4;
            v9 = v7 + v5;
            if (v8 < 1) {
                goto lab_0x8048adf;
            }
            goto lab_0x8048a25;
        }
        // 0x8048b07
        return result;
    }
}

// Address range: 0x8048b10 - 0x8048bcc
int32_t GenerateMaze(int32_t a1, int64_t a2, int32_t a3) {
    int32_t v1 = a2;
    for (int32_t i = 0; i < (int32_t)((int64_t)a3 * a2); i++) {
        // 0x8048b1f
        *(char *)(i + a1) = 1;
        // continue -> 0x8048b1f
    }
    int32_t v2 = a1 + 1; // 0x8048b3d
    *(char *)(v2 + v1) = 0;
    srandom(time(NULL));
    int32_t result; // 0x8048bc5
    if (a3 <= 1) {
        // 0x8048ba5
        *(char *)v2 = 0;
        result = a1 - 2 + v1 + (int32_t)((int64_t)(a3 - 1) * a2);
        *(char *)result = 0;
        return result;
    }
    int32_t v3 = 1;
    // branch -> 0x8048b91
    while (true) {
        // 0x8048b91
        int32_t v4; // 0x8048b99
        if (v1 > 1) {
            int32_t v5 = 1;
          lab_0x8048b73:
            while (true) {
                // 0x8048b73
                CarveMaze(a1, a2, a3, v5, v3);
                if (v5 + 2 >= v1) {
                    // break -> 0x8048b99
                    break;
                }
                v5 += 2;
                // continue -> 0x8048b73
            }
            // 0x8048b99
            v4 = v3 + 2;
            if (v4 >= a3) {
                // break -> 0x8048ba5
                break;
            }
            v3 = v4;
            // continue -> 0x8048b91
            continue;
        }
      lab_0x8048b99:
        // 0x8048b99
        v4 = v3 + 2;
        if (v4 >= a3) {
            // break -> 0x8048ba5
            break;
        }
        v3 = v4;
        // continue -> 0x8048b91
    }
    // 0x8048ba5
    *(char *)v2 = 0;
    result = a1 - 2 + v1 + (int32_t)((int64_t)(a3 - 1) * a2);
    *(char *)result = 0;
    return result;
}

// Address range: 0x8048d90 - 0x8048def
void make_immortal(void) {
    puts("Welcome to the HIGH MENU elite!");
    puts("Please enter your name:");
    fflush(g1);
    int32_t buf;
    read(0, (char *)&buf, 520);
}

// Address range: 0x8048df0 - 0x804905f
int main(int argc, char ** argv) {
    char * mem = malloc(1849); // 0x8048e1a
    int32_t v1 = (int32_t)mem; // 0x8048e1a_3
    if (mem == NULL) {
        // 0x8048e2b
        puts("error: not enough memory");
        fflush(g1);
        exit(1);
        // UNREACHABLE
    }
    // 0x8048e56
    GenerateMaze(v1, 43, 43);
    signal(SIGALARM, (void (**)(int32_t))sig_alarm_handler);
    alarm(30);
    *(char *)(v1 + 1) = 2;
    ShowMaze(v1, 43, 43);
    int32_t v2 = 0; // 0x8048fd775
    int32_t v3 = 1; // 0x8048fdd71
    // branch -> 0x8048eff
    while (true) {
        // 0x8048eff
        int32_t buf;
        read(0, (char *)&buf, 1);
        char v4 = buf;
        int32_t v5 = 0; // 0x8048fda69
        switch (v4) {
            case 65: {
                // 0x8048f30
                // branch -> 0x8048f34
                v5 = -1;
            }
            default: {
              lab_0x8048f34:;
                int32_t v6 = v5; // 0x8048fda68
                switch (v4) {
                    case 68: {
                        // 0x8048f44
                        // branch -> 0x8048f48
                        v6 = v5 + 1;
                    }
                    default: {
                      lab_0x8048f48:;
                        // 0x8048f48
                        int32_t v7; // 0x8048fd472
                        int32_t v8; // 0x8048fd47377
                        int32_t v9; // 0x8048fd47378
                        switch (v4) {
                            default: {
                                // 0x8048f5c
                                if (v4 != 83) {
                                    v8 = 0;
                                    // 0x8048f64
                                    if (v4 != 115) {
                                        v7 = v8;
                                      lab_0x8048f70_4:;
                                        int32_t v10 = v7 + v2; // 0x8048f76
                                        int32_t v11 = v6 + v3; // 0x8048f82
                                        char * v12 = (char *)(v11 + v1 + 43 * v10);
                                        int32_t v13; // 0x8048fd774
                                        int32_t v14; // 0x8048fdd70
                                        if (*v12 == 1) {
                                            // 0x8048fe2
                                            puts("DON'T RUN INTO WALLS");
                                            fflush(g1);
                                            v13 = v2;
                                            v14 = v3;
                                            // branch -> 0x8049003
                                        } else {
                                            // 0x8048f9c
                                            *(char *)(v3 + v1 + 43 * v2) = 0;
                                            *v12 = 2;
                                            v13 = v10;
                                            v14 = v11;
                                            // branch -> 0x8049003
                                        }
                                        // 0x8049003
                                        if (*(char *)(v1 + 1847) == 2) {
                                            // 0x8049023
                                            make_immortal();
                                            free(mem);
                                            exit(0);
                                            // UNREACHABLE
                                        }
                                        // 0x8049040
                                        ShowMaze(v1, 43, 43);
                                        v2 = v13;
                                        v3 = v14;
                                        // branch -> 0x8048eff
                                        continue;
                                    } else {
                                        v9 = v8;
                                    }
                                } else {
                                    v9 = 0;
                                }
                                break;
                            }
                            case 87: {
                                v8 = -1;
                                // 0x8048f64
                                if (v4 != 115) {
                                    v7 = v8;
                                    goto lab_0x8048f70_4;
                                }
                              lab_0x8048f6c:
                                // 0x8048f6c
                                v7 = v8 + 1;
                                // branch -> 0x8048f70
                                goto lab_0x8048f70_4;
                                break;
                            }
                            case 119: {
                                v8 = -1;
                                // 0x8048f64
                                if (v4 == 115) {
                                    goto lab_0x8048f6c;
                                }
                                v7 = v8;
                                goto lab_0x8048f70_4;
                                break;
                            }
                        }
                        // 0x8048f6c
                        v7 = v9 + 1;
                        // branch -> 0x8048f70
                        goto lab_0x8048f70_4;
                        break;
                    }
                    case 100: {
                        // 0x8048f44
                        v6 = v5 + 1;
                        // branch -> 0x8048f48
                        goto lab_0x8048f48;
                        break;
                    }
                }
                break;
            }
            case 97: {
                // 0x8048f30
                v5 = -1;
                // branch -> 0x8048f34
                goto lab_0x8048f34;
            }
        }
    }
}